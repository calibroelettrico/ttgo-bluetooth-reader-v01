<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Macro-Riconoscimento Numerico WAP</title>
    <style>
        /* Stili per adattarsi a uno smartphone */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Evita lo scrolling */
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }

        /* Contenitore della Camera (Metà Superiore) */
        #camera-container {
            flex: 1; /* Occupa la metà superiore (50%) */
            position: relative;
            overflow: hidden;
            background-color: #000;
        }

        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Assicura che il video riempia l'area */
            transform: scaleX(-1); /* Specchia il video se è la fotocamera frontale, altrimenti si può rimuovere */
        }

        /* Area di Selezione (Riquadro) */
        #selection-box {
            position: absolute;
            border: 2px solid lime;
            background-color: rgba(0, 255, 0, 0.2);
            cursor: move;
            display: none; /* Inizialmente nascosto */
            box-sizing: border-box;
            user-select: none;
            touch-action: none; /* Per un corretto dragging su touch screen */
        }

        /* Controlli (Metà Inferiore) */
        #controls-container {
            flex: 1; /* Occupa la metà inferiore (50%) */
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background-color: #f0f0f0;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 15px;
            flex-grow: 1;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: white;
            font-weight: bold;
        }

        #recognize-btn { background-color: #007bff; }
        #correct-btn { background-color: #28a745; }

        input[type="text"], input[type="number"], #recognition-result {
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
            flex-grow: 2; /* Più spazio per il risultato/input */
        }

        #recognition-result {
            background-color: white;
            text-align: center;
            font-weight: bold;
            color: #d9534f;
        }

        /* Elemento nascosto per la cattura dell'immagine */
        #photo-canvas {
            display: none;
        }
    </style>
</head>
<body>

    <div id="camera-container">
        <video id="video-feed" autoplay playsinline></video>
        <div id="selection-box"></div>
    </div>

    <div id="controls-container">
        <div class="control-group">
            <button id="recognize-btn">RICONOSCI</button>
            <div id="recognition-result">Risposta (cm)</div>
        </div>

        <div class="control-group">
            <button id="correct-btn">CORREGGI</button>
            <input type="number" id="correction-input" placeholder="Inserisci il numero corretto" pattern="[0-9]*" inputmode="numeric">
        </div>

        <p style="font-size: 0.8em; color: #555;">
            *Nota: OCR/IA sono simulati. In un'applicazione reale, occorrerebbe una libreria OCR/ML e un modello.
        </p>
    </div>

    <canvas id="photo-canvas"></canvas>

    <script>
        const video = document.getElementById('video-feed');
        const cameraContainer = document.getElementById('camera-container');
        const selectionBox = document.getElementById('selection-box');
        const recognizeBtn = document.getElementById('recognize-btn');
        const correctBtn = document.getElementById('correct-btn');
        const recognitionResult = document.getElementById('recognition-result');
        const correctionInput = document.getElementById('correction-input');
        const canvas = document.getElementById('photo-canvas');
        const ctx = canvas.getContext('2d');

        // Variabili per il Drag and Drop (Spostamento e Ridimensionamento per la Selezione)
        let isDragging = false;
        let startX, startY;
        let offsetX, offsetY;
        
        // --- 1. Gestione della Fotocamera (Macro Simulato) ---
        async function startCamera() {
            try {
                // Tenta di accedere alla fotocamera posteriore con risoluzione elevata (per dettaglio)
                // e focusMode 'macro' o 'close-up' (se supportato, spesso non è una proprietà standard)
                const constraints = {
                    video: {
                        facingMode: { ideal: 'environment' }, // Fotocamera posteriore
                        // Prova ad impostare proprietà per simulare "macro"
                        // La vera macro dipende dall'hardware e dal supporto del browser
                        width: { ideal: 1920 }, 
                        height: { ideal: 1080 },
                        // Esempi di possibili vincoli avanzati (non standard in tutti i browser):
                        // advanced: [{ focusMode: "close-up" }, { focusDistance: 0.1 }] 
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                // Una volta che il video è caricato, lo specchia nuovamente
                video.onloadedmetadata = () => {
                    video.play();
                    // Assicurati che non ci sia uno specchio se è la camera posteriore
                    video.style.transform = 'scaleX(1)'; 
                    // Mostra il riquadro di selezione con un valore predefinito
                    selectionBox.style.display = 'block';
                    selectionBox.style.width = '150px';
                    selectionBox.style.height = '75px';
                    selectionBox.style.left = (cameraContainer.offsetWidth / 2 - 75) + 'px';
                    selectionBox.style.top = (cameraContainer.offsetHeight / 2 - 37.5) + 'px';
                };
            } catch (err) {
                console.error("Errore nell'accesso alla fotocamera: ", err);
                recognitionResult.textContent = "Errore: Camera non accessibile.";
            }
        }

        // --- 3. Gestione del Riquadro di Selezione (Drag and Drop) ---
        function handleStart(e) {
            e.preventDefault();
            isDragging = true;
            
            // Gestione evento touch o mouse
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Calcola l'offset iniziale rispetto al container della camera
            const rect = selectionBox.getBoundingClientRect();
            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;

            // Calcola il punto di partenza del container
            const containerRect = cameraContainer.getBoundingClientRect();
            startX = containerRect.left;
            startY = containerRect.top;

            selectionBox.style.cursor = 'grabbing';
        }

        function handleMove(e) {
            if (!isDragging) return;
            e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            let newLeft = clientX - startX - offsetX;
            let newTop = clientY - startY - offsetY;

            // Limita il movimento all'interno del camera-container
            newLeft = Math.max(0, Math.min(newLeft, cameraContainer.offsetWidth - selectionBox.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, cameraContainer.offsetHeight - selectionBox.offsetHeight));

            selectionBox.style.left = newLeft + 'px';
            selectionBox.style.top = newTop + 'px';
        }

        function handleEnd() {
            isDragging = false;
            selectionBox.style.cursor = 'move';
        }

        // Aggiungi listener per il movimento (sia mouse che touch)
        selectionBox.addEventListener('mousedown', handleStart);
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd);

        selectionBox.addEventListener('touchstart', handleStart);
        document.addEventListener('touchmove', handleMove);
        document.addEventListener('touchend', handleEnd);

        // --- 4. Funzione RICONOSCI (Cattura e IA Simulato) ---
        recognizeBtn.addEventListener('click', () => {
            recognitionResult.textContent = '... Riconoscimento in corso ...';

            // Dati di posizione e dimensione del riquadro nel video feed
            const containerRect = cameraContainer.getBoundingClientRect();
            const boxRect = selectionBox.getBoundingClientRect();

            // Calcola le coordinate relative del riquadro all'interno del container
            const relativeLeft = boxRect.left - containerRect.left;
            const relativeTop = boxRect.top - containerRect.top;
            const boxWidth = boxRect.width;
            const boxHeight = boxRect.height;

            // La dimensione del video può essere diversa dalla dimensione del container (object-fit: cover)
            // Per la cattura precisa, impostiamo il canvas alla dimensione nativa del video
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            
            // Calcola il fattore di scala
            const scaleX = videoWidth / containerRect.width;
            const scaleY = videoHeight / containerRect.height;

            // Coordinate e dimensioni sul video nativo
            const sx = relativeLeft * scaleX;
            const sy = relativeTop * scaleY;
            const sWidth = boxWidth * scaleX;
            const sHeight = boxHeight * scaleY;

            // Imposta la dimensione del canvas per la parte da analizzare (per l'OCR)
            canvas.width = sWidth;
            canvas.height = sHeight;

            // Disegna sul canvas SOLO la parte selezionata (cropping)
            ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

            // --- SIMULAZIONE OCR/IA (Velocità privilegiata) ---
            setTimeout(() => {
                // In un'applicazione reale, qui si caricherebbe l'immagine dal canvas e la si passerebbe al motore OCR/ML
                // Esempio: Tesseract.recognize(canvas).then(...)
                
                // SIMULAZIONE: Genera un numero casuale per la risposta
                const recognizedNumber = Math.floor(Math.random() * 90 + 10); // Numero casuale 10-99
                recognitionResult.textContent = `${recognizedNumber} cm`;
                
                console.log(`Foto catturata e croppata. Numero riconosciuto (simulato): ${recognizedNumber}`);
                
                // Se si volesse visualizzare l'immagine catturata:
                // document.body.appendChild(canvas);
            }, 500); // Ritardo simulato per l'elaborazione
        });

        // --- 5. Funzione CORREGGI (Training Simulato) ---
        correctBtn.addEventListener('click', () => {
            const correctedValue = correctionInput.value.trim();

            if (!correctedValue || isNaN(correctedValue)) {
                recognitionResult.textContent = '⚠ Inserisci un numero valido.';
                return;
            }

            recognitionResult.textContent = `... Training con ${correctedValue} ...`;

            // Qui in un'applicazione reale avverrebbe il *training* (fine-tuning) del modello
            // utilizzando l'ultima immagine catturata (quella sul canvas) e il valore `correctedValue`
            
            // Questo processo è computazionalmente intenso e molto lento.
            // SIMULAZIONE: Mostra un messaggio di successo e ripulisce il campo
            setTimeout(() => {
                recognitionResult.textContent = `Riconoscimento migliorato con ${correctedValue}!`;
                correctionInput.value = '';
                console.log(`Training simulato completato con valore: ${correctedValue}`);
            }, 1000); // Ritardo simulato per il training
        });

        // Avvia la fotocamera all'avvio
        startCamera();
    </script>
</body>
</html>
